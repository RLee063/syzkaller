#!/bin/python3

def parse_name(line: str):
	name = line[line.find("BPF"): line.find("(")]
	args = line[line.find("(")+1: line.find(")")]
	args = args.replace(" ", "").split(",")
	return name, args

def parse_code(line: str):
	code = line[line.find("BPF"): line.find(",")]
	return code.replace(" ", "").split("|")

def parse_arg(line):
    if line.find(",") != -1 and line.find(",") < line.find("}"):
        return line[line.find("=")+2: line.find(",")]
    else:
        return line[line.find("=")+2: line.find("}")-1]

header = """
type bpf_insn_t_k[CLASS, SRC_SIZE, OP_MODE, DST, SRC, OFF, IMM] {
	code_class	CLASS
	code_ss		SRC_SIZE
	code_o		OP_MODE
	dst			DST
	src			SRC
	off			OFF
	imm			IMM
}

define BPF_K0 BPF_K >> 3
define BPF_X0 BPF_X >> 3

bpf_alu_shift [
	reg64 bpf_alu_shift64_reg
	reg32 bpf_alu_shift32_reg
	imm64 bpf_alu_shift64_imm
	imm32 bpf_alu_shift32_imm
]
"""

BPF_LD_IMM64_RAW_str = """
type BPF_LD_IMM64[DST, IMML, IMMH] BPF_LD_IMM64_RAW[DST, 0, IMML, IMMH]
type bpf_ld_imm64 bpf_ld_imm64_raw_t[flags[bpf_dst_reg, int8:4], const[0, int8:4], int32, int32]

type BPF_LD_MAP_FD[DST, MAP_FD] BPF_LD_IMM64_RAW[DST, BPF_PSEUDO_MAP_FD, MAP_FD, 0]
type bpf_ld_map_fd bpf_ld_imm64_raw_t[flags[bpf_dst_reg, int8:4], const[BPF_PSEUDO_MAP_FD, int8:4], flags[bpf_map_fd, int32], const[0, int32]]

type BPF_LD_IMM64_RAW[DST, SRC, IMML, IMMH] bpf_ld_imm64_raw_t[const[DST, int8:4], const[SRC, int8:4], const[IMML, int32], const[IMMH, int32]]
type bpf_ld_imm64_raw  bpf_ld_imm64_raw_t[flags[bpf_dst_reg, int8:4], flags[bpf_src_reg, int8:4], int32, int32]
type bpf_ld_imm64_raw_t[DST, SRC, IMML, IMMH]{
	low 	bpf_insn_t_k[const[BPF_LD, int8:3], const[BPF_DW0, int8:2], const[BPF_IMM, int8:3], DST, SRC, const[0, int16], IMML]
	high	bpf_insn_t_k[const[0, int8:3], const[0, int8:1], const[0, int8:4], const[0, int8:4], const[0, int8:4], const[0, int16], IMMH]
} 
"""
BPF_EXIT_INSN_str =  """
type BPF_EXIT_INSN bpf_exit_insn
type bpf_exit_insn bpf_insn_t_k[const[BPF_JMP, int8:3], const[0, int8:1], const[BPF_EXIT0, int8:4], const[0, int8:4], const[0, int8:4], const[0, int16], const[0, int32]]
"""

BPF_ALU_SHIFT_INSN_str = """
type bpf_alu_shift64_reg_t[OP, DST, SRC] bpf_insn_t_k[const[BPF_ALU64, int8:3], const[BPF_X0, int8:1], OP, DST, SRC, const[0, int16], const[0, int32]]
type bpf_alu_shift64_reg bpf_alu_shift64_reg_t[flags[bpf_alu_shift_op_k, int8:4], flags[bpf_dst_reg, int8:4], flags[bpf_src_reg, int8:4]] 

type bpf_alu_shift32_reg_t[OP, DST, SRC] bpf_insn_t_k[const[BPF_ALU, int8:3], const[BPF_X0, int8:1], OP, DST, SRC, const[0, int16], const[0, int32]]
type bpf_alu_shift32_reg bpf_alu_shift32_reg_t[flags[bpf_alu_shift_op_k, int8:4], flags[bpf_dst_reg, int8:4], flags[bpf_src_reg, int8:4]]

type bpf_alu_shift64_imm_t[OP, DST, IMM] bpf_insn_t_k[const[BPF_ALU64, int8:3], const[BPF_K0, int8:1], OP, DST, const[0, int8:4], const[0, int16], IMM]
type bpf_alu_shift64_imm bpf_alu_shift64_imm_t[flags[bpf_alu_shift_op_k, int8:4], flags[bpf_dst_reg, int8:4], int32[0:64]]

type bpf_alu_shift32_imm_t[OP, DST, IMM] bpf_insn_t_k[const[BPF_ALU, int8:3], const[BPF_K0, int8:1], OP, DST, const[0, int8:4], const[0, int16], IMM]
type bpf_alu_shift32_imm bpf_alu_shift32_imm_t[flags[bpf_alu_shift_op_k, int8:4], flags[bpf_dst_reg, int8:4], int32[0:32]]
"""
print("# ===== BPF_INSNS (generated by extract-description.py) =====")
print(BPF_ALU_SHIFT_INSN_str)
with open("/home/k1ll3r/work_space/ebpf_learning/syzkaller_study/bpf_insn.h") as f:
	defines = f.readlines()

it = iter(defines)

for line in it:
	if "define" not in line:
		continue
	next_line = next(it)
	if "struct bpf_insn" not in next_line:
		continue
	name, args = parse_name(line)
	line = next(it)
	code = parse_code(line)
	if name in ["BPF_RAW_INSN"]:
		continue
	elif name == "BPF_LD_IMM64_RAW":
		print(BPF_LD_IMM64_RAW_str)
	elif name == "BPF_EXIT_INSN":
		print(BPF_EXIT_INSN_str)
	elif code[0] in ["BPF_ALU64", "BPF_ALU", "BPF_JMP", "BPF_JMP32"]:
		str_template = "type {}[{}] bpf_insn_t_k[{}, {}, {}, {}, {}, {}, {}]".format(
			name.lower()+"_t",
			", ".join(args),
			"const[{}, int8:3]".format(code[0]),
			"const[{}, int8:1]".format(code[2]+"0") if len(code)>2 else "const[0, int8:1]",
			"OP" if "OP" in args else "const[{}, int8:4]".format(code[1]+"0"),
			"DST" if "DST" in args else "const[0, int8:4]",
			"SRC" if "SRC" in args else "const[0, int8:4]",
			"OFF" if "OFF" in args else "const[0, int16]",
			"IMM" if "IMM" in args else "const[0, int32]",
		)
		print(str_template)

		str_random_args = []
		for a in args:
			if a == "OP":
				if "ALU" in name:
					a_str = "flags[bpf_alu_op_k, int8:4]"
				elif "JMP" in name:
					a_str = "flags[bpf_jmp_op_k, int8:4]"
			elif a == "DST":
				a_str = "flags[bpf_dst_reg, int8:4]"
			elif a == "SRC":
				a_str = "flags[bpf_src_reg, int8:4]"
			elif a == "OFF":
				# a_str = "flags[bpf_insn_offsets, int16]"
				if code[0] in ["BPF_JMP", "BPF_JMP32"]:
					a_str = "int16[0:10]"
				else:
					a_str = "int16"
			elif a == "IMM":
				# a_str = "flags[bpf_insn_immediates, int32]"
				a_str = "int32"
			str_random_args.append(a_str)
		str_random = "type {} {}[{}]".format(
			name.lower(),
			name.lower()+"_t",
			", ".join(str_random_args)
		)
		print(str_random)

		str_helper_args = []
		for a in args:
			if a == "OP":
				a_str = "const[OP, int8:4]"
			elif a == "DST" or a == "SRC":
				a_str = "const[{}, int8:4]".format(a)
			elif a == "OFF":
				a_str = "const[OFF, int16]"
			elif a == "IMM":
				a_str = "const[IMM, int32]"
			str_helper_args.append(a_str)
		str_helper = "type {}[{}] {}[{}]".format(
			name.upper(),
			", ".join(args),
			name.lower()+"_t",
			", ".join(str_helper_args)
		)
		print(str_helper, "\n")
	elif "LD" in name or "ST" in name:
		str_template = "type {}[{}] bpf_insn_t_k[{}, {}, {}, {}, {}, {}, {}]".format(
			name.lower()+"_t",
			", ".join(args),
			"const[{}, int8:3]".format(code[0]),
			"SIZE",
			"const[{}, int8:3]".format(code[2]+"0"),
			"DST" if "DST" in args else "const[0, int8:4]",
			"SRC" if "SRC" in args else "const[0, int8:4]",
			"OFF" if "OFF" in args else "const[0, int16]",
			"IMM" if "IMM" in args else "const[0, int32]",
		)
		print(str_template)

		str_random_args = []
		for a in args:
			if a == "SIZE":
				a_str = "flags[bpf_ldst_size, int8:2]"
			elif a == "DST":
				if "LD" in name:
					a_str = "flags[bpf_dst_reg, int8:4]"
				elif "ST" in name:
					a_str = "flags[bpf_map_reg, int8:4]"
			elif a == "SRC":
				if "LD" in name:
					a_str = "flags[bpf_map_reg, int8:4]"
				elif "ST" in name:
					a_str = "flags[bpf_src_reg, int8:4]"
			elif a == "OFF":
				# a_str = "flags[bpf_insn_offsets, int16]"
				a_str = "int16"
			elif a == "IMM":
				# a_str = "flags[bpf_insn_immediates, int32]"
				a_str = "int32"
			str_random_args.append(a_str)
		str_random = "type {} {}[{}]".format(
			name.lower(),
			name.lower()+"_t",
			", ".join(str_random_args)
		)
		print(str_random)

		str_helper_args = []
		for a in args:
			if a == "SIZE":
				a_str = "const[SIZE, int8:2]"
			elif a == "DST" or a == "SRC":
				a_str = "const[{}, int8:4]".format(a)
			elif a == "OFF":
				a_str = "const[OFF, int16]"
			elif a == "IMM":
				a_str = "const[IMM, int32]"
			str_helper_args.append(a_str)
		str_helper = "type {}[{}] {}[{}]".format(
			name.upper(),
			", ".join(args),
			name.lower()+"_t",
			", ".join(str_helper_args)
		)
		print(str_helper, "\n")
	else:
		pass
